<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0d1117">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Wizz AYCF Flight Finder</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#0d1117;--s1:#161b22;--s2:#1c2333;--s3:#252d3d;
  --bdr:#30363d;--bdr2:#484f58;
  --acc:#58a6ff;--acc2:#a371f7;--grn:#3fb950;--ylw:#d29922;--red:#f85149;
  --tx:#e6edf3;--tx2:#8b949e;--tx3:#6e7681;
  --r:10px;--rs:6px;
}
html{font-size:15px}
body{font-family:'Inter',system-ui,sans-serif;background:var(--bg);color:var(--tx);min-height:100vh;padding-bottom:20px}

.hd{position:sticky;top:0;z-index:100;background:rgba(13,17,23,.95);backdrop-filter:blur(16px);border-bottom:1px solid var(--bdr);padding:10px 14px}
.hd-r{display:flex;align-items:center;justify-content:space-between;max-width:900px;margin:0 auto}
.hd-t{font-size:1rem;font-weight:800;display:flex;align-items:center;gap:8px}
.hd-t .g{background:linear-gradient(90deg,var(--acc),var(--acc2));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.hd-t .v{font-weight:400;font-size:.6rem;color:var(--tx3)}
.hd-a{display:flex;gap:4px}
.ib{width:36px;height:36px;border-radius:8px;border:1px solid var(--bdr);background:var(--s1);color:var(--tx2);display:flex;align-items:center;justify-content:center;cursor:pointer}

.ct{max-width:900px;margin:0 auto;padding:10px 12px}
.cd{background:var(--s1);border:1px solid var(--bdr);border-radius:var(--r);padding:14px;margin-bottom:10px}
.cd-t{font-size:.72rem;font-weight:700;text-transform:uppercase;letter-spacing:.07em;color:var(--tx2);margin-bottom:10px}

.bt{display:inline-flex;align-items:center;gap:4px;padding:10px 14px;border-radius:var(--rs);border:none;font-family:'Inter',sans-serif;font-size:.82rem;font-weight:600;cursor:pointer;min-height:40px}
.bt:disabled{opacity:.3;pointer-events:none}
.bt-p{background:var(--acc);color:#0d1117}
.bt-g{background:var(--grn);color:#0d1117}
.bt-y{background:var(--ylw);color:#0d1117}
.bt-o{background:transparent;border:1px solid var(--bdr);color:var(--tx2)}
.bt-d{background:rgba(248,81,73,.12);border:1px solid rgba(248,81,73,.3);color:var(--red)}
.bt-sm{padding:7px 10px;font-size:.76rem;min-height:34px}
.rw{display:flex;gap:6px;flex-wrap:wrap}

.ip{width:100%;background:var(--s2);border:1px solid var(--bdr);border-radius:var(--rs);padding:11px 12px;color:var(--tx);font-family:'Inter',sans-serif;font-size:.88rem;min-height:42px}
.ip:focus{outline:none;border-color:var(--acc)}
select.ip{font-weight:600;color:var(--tx);-webkit-appearance:none;appearance:none;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath d='M3 5l3 3 3-3' stroke='%238b949e' fill='none' stroke-width='1.5'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right 10px center;padding-right:28px}
select.ip option{color:#000;background:#fff}
select.ip[multiple]{height:42px;overflow:hidden}
.ip-row{display:flex;gap:8px;margin-bottom:8px}

.filter-row{display:flex;gap:10px;align-items:flex-start;margin-bottom:10px;flex-wrap:wrap}
.filter-row label{font-size:.75rem;font-weight:600;color:var(--tx2);min-width:100px;padding-top:12px}
.filter-row select,.filter-row input{flex:1;min-width:120px}

.chk-row{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.chk-row input[type="checkbox"]{width:18px;height:18px;accent-color:var(--acc)}
.chk-row label{font-size:.78rem;color:var(--tx2)}

.mg{padding:12px;border-radius:var(--rs);margin-bottom:8px;font-size:.82rem}
.mg-i{background:rgba(88,166,255,.06);border:1px solid rgba(88,166,255,.2);color:#79c0ff}
.mg-s{background:rgba(63,185,80,.06);border:1px solid rgba(63,185,80,.2);color:var(--grn)}
.mg-w{background:rgba(210,153,34,.06);border:1px solid rgba(210,153,34,.2);color:var(--ylw)}
.mg-e{background:rgba(248,81,73,.06);border:1px solid rgba(248,81,73,.2);color:var(--red)}

.pg{height:4px;background:rgba(88,166,255,.12);border-radius:2px;overflow:hidden;margin:6px 0}
.pg .fl{height:100%;background:linear-gradient(90deg,var(--acc),var(--acc2));border-radius:2px;transition:width .3s;width:0%}

.hd-n{display:none!important}
.sep{border:none;border-top:1px solid var(--bdr);margin:12px 0}
.sp-n{display:inline-block;width:14px;height:14px;border:2px solid rgba(88,166,255,.2);border-top-color:var(--acc);border-radius:50%;animation:spi .6s linear infinite}
@keyframes spi{to{transform:rotate(360deg)}}

/* Multi-select chips */
.chips{display:flex;flex-wrap:wrap;gap:4px;margin-top:6px}
.chip{display:inline-flex;align-items:center;gap:4px;background:rgba(88,166,255,.15);border:1px solid var(--acc);border-radius:12px;padding:4px 8px;font-size:.72rem;color:var(--acc)}
.chip .x{cursor:pointer;font-weight:bold;margin-left:2px}
.chip .x:hover{color:var(--red)}

/* Results Table */
.results-controls{display:flex;gap:8px;margin-bottom:10px;flex-wrap:wrap;align-items:center}
.results-count{font-size:.8rem;color:var(--tx2);margin-left:auto}

.tbl-wrap{overflow-x:auto;border:1px solid var(--bdr);border-radius:var(--rs)}
table{width:100%;border-collapse:collapse;font-size:.78rem}
th,td{padding:10px 8px;text-align:left;border-bottom:1px solid var(--bdr)}
th{background:var(--s2);font-weight:600;color:var(--tx2);cursor:pointer;user-select:none;white-space:nowrap}
th:hover{background:var(--s3)}
th.sorted-asc::after{content:' â–²';color:var(--acc)}
th.sorted-desc::after{content:' â–¼';color:var(--acc)}
tr:hover{background:var(--s2)}
td{color:var(--tx)}
.mono{font-family:'JetBrains Mono',monospace}
.link-btn{background:var(--grn);color:#0d1117;padding:4px 8px;border-radius:4px;text-decoration:none;font-size:.7rem;font-weight:600;white-space:nowrap}

.th-filter{display:block;margin-top:4px}
.th-filter input{width:100%;padding:4px 6px;font-size:.7rem;background:var(--bg);border:1px solid var(--bdr);border-radius:3px;color:var(--tx)}

/* Modal */
.mo{display:none;position:fixed;inset:0;background:rgba(0,0,0,.7);z-index:200;align-items:flex-end;justify-content:center}
.mo.op{display:flex}
.mo-s{width:100%;max-width:520px;background:var(--s1);border-radius:14px 14px 0 0;padding:16px 14px 24px;max-height:88vh;overflow-y:auto}
.mo-h{width:36px;height:3px;background:var(--tx3);border-radius:2px;margin:0 auto 12px}
.mo-t{font-size:1rem;font-weight:700;margin-bottom:12px}

.la{background:var(--bg);border:1px solid var(--bdr);border-radius:var(--rs);max-height:400px;overflow-y:auto;padding:8px;font-family:'JetBrains Mono',monospace;font-size:.6rem;color:var(--tx3);white-space:pre-wrap;word-break:break-all}
.la .e{color:var(--red)}.la .w{color:var(--ylw)}.la .s{color:var(--grn)}.la .a{color:var(--acc)}.la .v{color:var(--acc2)}

.cl-h{cursor:pointer;display:flex;justify-content:space-between;align-items:center}
.cl-h .tg{font-size:.65rem;color:var(--tx3)}
.cl-b{display:none;margin-top:10px}.cl-b.op{display:block}
.stp{counter-reset:step;margin:10px 0}
.sp{counter-increment:step;padding-left:30px;position:relative;margin-bottom:10px;font-size:.8rem;color:var(--tx2)}
.sp::before{content:counter(step);position:absolute;left:0;top:0;width:22px;height:22px;border-radius:50%;background:var(--acc);color:var(--bg);font-size:.7rem;font-weight:700;display:flex;align-items:center;justify-content:center}
.code-box{background:var(--bg);border:1px solid var(--bdr);border-radius:var(--rs);padding:8px;font-family:'JetBrains Mono',monospace;font-size:.62rem;color:var(--acc);max-height:100px;overflow-y:auto;margin:6px 0}

.ft{display:flex;justify-content:space-between;align-items:center;font-size:.68rem;color:var(--tx3);padding:18px 12px;max-width:900px;margin:0 auto}
.ft a{color:var(--acc);text-decoration:none}
.ft-brand{display:flex;align-items:center;gap:6px}
.ft-brand img{width:20px;height:20px;border-radius:4px}
.ft-brand span{font-weight:600;color:var(--tx2)}

.date-box{display:inline-flex;align-items:center;gap:6px;background:var(--s3);padding:8px 12px;border-radius:var(--rs);font-family:'JetBrains Mono',monospace;font-size:.9rem;color:var(--grn);font-weight:600}
.date-note{font-size:.65rem;color:var(--tx3);margin-left:8px}
</style>
</head>
<body>

<header class="hd">
<div class="hd-r">
  <div class="hd-t">
    <span class="g">âœˆï¸ AYCF Finder</span>
    <span class="v" id="versionDisplay">v4.13.0</span>
  </div>
  <div class="hd-a">
    <button class="ib" id="bLog" title="Debug Log">ğŸ”§</button>
    <button class="ib" id="bSettings" title="Settings">âš™ï¸</button>
  </div>
</div>
</header>

<main class="ct">

<!-- Proxy Setup -->
<div class="cd" id="proxySetup">
  <div class="cd-t">ğŸ”§ One-Time Setup (required)</div>
  <p style="font-size:.8rem;color:var(--tx2);margin-bottom:10px">
    To connect to Wizz Air, you need a free <strong style="color:var(--tx)">Cloudflare Worker</strong> proxy.
  </p>
  <div class="cl-h" id="setupHdr"><span style="font-size:.78rem;font-weight:600;color:var(--acc)">ğŸ“‹ Setup Instructions</span><span class="tg">â–¼</span></div>
  <div class="cl-b" id="setupBody">
    <div class="stp">
      <div class="sp">Go to <a href="https://dash.cloudflare.com/sign-up" target="_blank" style="color:var(--acc)">Cloudflare</a> â†’ Create free account</div>
      <div class="sp"><strong style="color:var(--tx)">Workers & Pages</strong> â†’ <strong style="color:var(--tx)">Create</strong></div>
      <div class="sp">Click <strong style="color:var(--tx)">"Start with Hello World!"</strong></div>
      <div class="sp">Name it (e.g. <code style="color:var(--acc)">aycf-proxy</code>) â†’ Click <strong style="color:var(--tx)">Deploy</strong></div>
      <div class="sp">Click <strong style="color:var(--tx)">"Edit Code"</strong> â†’ Delete all â†’ Paste code below â†’ <strong style="color:var(--tx)">Deploy</strong></div>
      <div class="sp">Copy your Worker URL and paste below</div>
    </div>
    <button class="bt bt-p bt-sm" id="bCopyWorker">ğŸ“‹ Copy Worker Code</button>
    <div class="code-box hd-n" id="workerCode"></div>
  </div>
  <div class="ip-row" style="margin-top:10px">
    <input class="ip" id="proxyUrl" placeholder="https://your-worker.workers.dev">
    <button class="bt bt-g" id="bSaveProxy">Save</button>
    <button class="bt bt-p bt-sm" id="bTestProxy">ğŸ§ª Test</button>
  </div>
  <div id="proxyMsg" style="margin-top:6px"></div>
</div>

<!-- Login & Search -->
<div class="cd" id="loginCard">
  <div class="cd-t">ğŸ”‘ Login & Search Flights</div>
  <div class="ip-row">
    <input class="ip" id="wizEmail" type="email" placeholder="Wizz Air Email" autocomplete="email">
    <input class="ip" id="wizPass" type="password" placeholder="Password" autocomplete="current-password">
  </div>
  <div class="chk-row">
    <input type="checkbox" id="saveCredentials">
    <label for="saveCredentials">Remember credentials on this device</label>
  </div>

  <div class="cd-t" style="margin-top:14px">ğŸ¯ Search Filters</div>

  <div class="filter-row">
    <label>Departure Date:</label>
    <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
      <div class="date-box" id="dateDisplay" onclick="document.getElementById('filterDate').showPicker()" style="cursor:pointer">--/--/----</div>
      <input type="date" class="ip" id="filterDate" style="position:absolute;opacity:0;width:1px;height:1px;pointer-events:none">
      <button class="bt bt-o bt-sm" type="button" onclick="document.getElementById('filterDate').showPicker()">ğŸ“… Pick</button>
    </div>
  </div>

  <div class="filter-row">
    <label>Search Range:</label>
    <select class="ip" id="filterDateFlex" style="max-width:180px">
      <option value="1">Exact Date Only</option>
      <option value="2">Next 2 Days</option>
      <option value="3">Next 3 Days</option>
      <option value="7">Next 7 Days</option>
      <option value="14">Next 14 Days</option>
      <option value="30">Next 30 Days</option>
    </select>
  </div>

  <div class="filter-row">
    <label>Origin Cities:</label>
    <div style="flex:1">
      <select class="ip" id="filterOrigin" multiple size="1"></select>
      <div class="chips" id="originChips"></div>
      <div style="font-size:.65rem;color:var(--tx3);margin-top:4px">Hold Ctrl/Cmd to select multiple</div>
    </div>
  </div>

  <div class="filter-row">
    <label>Destination Cities:</label>
    <div style="flex:1">
      <select class="ip" id="filterDest" multiple size="1"></select>
      <div class="chips" id="destChips"></div>
      <div style="font-size:.65rem;color:var(--tx3);margin-top:4px">Leave empty for ALL destinations</div>
    </div>
  </div>

  <div class="filter-row">
    <label>Round Trip:</label>
    <select class="ip" id="filterRoundTrip" style="max-width:120px">
      <option value="no">No</option>
      <option value="yes">Yes</option>
    </select>
    <span style="font-size:.72rem;color:var(--tx3)">(Returns within 3-4 days)</span>
  </div>

  <div class="rw" style="margin-top:14px">
    <button class="bt bt-p" id="bSearch">ğŸ” Search Flights</button>
    <button class="bt bt-y hd-n" id="bPause">â¸ï¸ Pause</button>
    <button class="bt bt-o hd-n" id="bResume">â–¶ï¸ Resume</button>
    <button class="bt bt-d hd-n" id="bStop">â¹ï¸ Stop</button>
  </div>
  <div class="pg hd-n" id="dlProg"><div class="fl" id="dlFill"></div></div>
  <div id="dlStatus" style="font-size:.75rem;color:var(--tx2);margin-top:4px"></div>
  <div id="loginMsg"></div>
</div>

<!-- Results -->
<div class="cd" id="resultsCard">
  <div class="cd-t">ğŸ“Š Search Results</div>

  <div class="results-controls">
    <button class="bt bt-o bt-sm" id="bExportResults">ğŸ“¤ Export JSON</button>
    <button class="bt bt-o bt-sm" id="bImportResults">ğŸ“¥ Import JSON</button>
    <button class="bt bt-d bt-sm" id="bClearResults">ğŸ—‘ï¸ Clear</button>
    <input type="file" id="importFile" accept=".json" style="display:none">
    <span class="results-count" id="resultsCount">0 flights</span>
  </div>

  <div id="resultsArea">
    <div class="mg mg-i">No results yet. Search for flights above.</div>
  </div>
</div>

</main>

<footer class="ft">
  <div class="ft-brand">
    <img src="Palaya_Logo.png" alt="Palaya">
    <span>Palaya LTD</span>
  </div>
  <div>Not affiliated with Wizz Air</div>
</footer>

<!-- Settings Modal -->
<div class="mo" id="mSettings">
<div class="mo-s">
  <div class="mo-h"></div>
  <div class="mo-t">âš™ï¸ Settings</div>

  <div class="cd-t">Proxy URL</div>
  <div class="ip-row">
    <input class="ip" id="settingsProxy" placeholder="https://your-worker.workers.dev">
    <button class="bt bt-g bt-sm" id="bSaveSettingsProxy">Save</button>
  </div>

  <hr class="sep">

  <div class="cd-t">Priority Cities (Search Order)</div>
  <p style="font-size:.75rem;color:var(--tx2);margin-bottom:8px">
    Enter city codes separated by commas. These will be searched first.
  </p>
  <div class="ip-row">
    <input class="ip" id="priorityCities" placeholder="TLV, BCN, FCO, ATH" style="text-transform:uppercase">
    <button class="bt bt-g bt-sm" id="bSavePriority">Save</button>
  </div>

  <hr class="sep">

  <div class="cd-t">Verbose Logging</div>
  <div class="chk-row">
    <input type="checkbox" id="verboseLog" checked>
    <label for="verboseLog">Enable verbose logging (for troubleshooting)</label>
  </div>

  <hr class="sep">

  <div class="cd-t">Saved Credentials</div>
  <button class="bt bt-d bt-sm" id="bClearCredentials">ğŸ—‘ï¸ Clear Saved Credentials</button>

  <hr class="sep">
  <button class="bt bt-o" style="width:100%" id="bCloseSettings">Close</button>
</div>
</div>

<!-- Log Modal -->
<div class="mo" id="mLog">
<div class="mo-s">
  <div class="mo-h"></div>
  <div class="mo-t">ğŸ”§ Debug Log <span id="lCnt" style="font-size:.72rem;color:var(--tx3)">(0)</span></div>
  <p style="font-size:.72rem;color:var(--tx2);margin-bottom:8px">Copy this log and send for troubleshooting support.</p>
  <div class="rw" style="margin-bottom:10px">
    <button class="bt bt-p bt-sm" id="bCopyLog">ğŸ“‹ Copy Full Log</button>
    <button class="bt bt-o bt-sm" id="bDownloadLog">ğŸ’¾ Download</button>
    <button class="bt bt-d bt-sm" id="bClearLog">Clear</button>
  </div>
  <div class="la" id="logArea">Waiting for events...</div>
  <hr class="sep">
  <button class="bt bt-o" style="width:100%" id="bCloseLog">Close</button>
</div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PALAYA LTD - WIZZ AYCF FINDER v4.4
//  With verbose logging for troubleshooting
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const VERSION = '4.12.0';

// UUID v4 generator for availability API
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// Dynamic search URL extracted from page (session-specific)
let dynamicSearchUrl = null;

// Airport Database
const AIRPORTS = {
  TLV:{city:'Tel Aviv',airport:'Ben Gurion International',country:'Israel'},
  ETH:{city:'Eilat',airport:'Ramon Airport',country:'Israel'},
  LTN:{city:'London',airport:'Luton Airport',country:'United Kingdom'},
  LGW:{city:'London',airport:'Gatwick Airport',country:'United Kingdom'},
  STN:{city:'London',airport:'Stansted Airport',country:'United Kingdom'},
  BHX:{city:'Birmingham',airport:'Birmingham Airport',country:'United Kingdom'},
  MAN:{city:'Manchester',airport:'Manchester Airport',country:'United Kingdom'},
  EDI:{city:'Edinburgh',airport:'Edinburgh Airport',country:'United Kingdom'},
  GLA:{city:'Glasgow',airport:'Glasgow Airport',country:'United Kingdom'},
  LPL:{city:'Liverpool',airport:'John Lennon Airport',country:'United Kingdom'},
  FCO:{city:'Rome',airport:'Fiumicino Airport',country:'Italy'},
  CIA:{city:'Rome',airport:'Ciampino Airport',country:'Italy'},
  MXP:{city:'Milan',airport:'Malpensa Airport',country:'Italy'},
  BGY:{city:'Milan',airport:'Bergamo Orio al Serio',country:'Italy'},
  VCE:{city:'Venice',airport:'Marco Polo Airport',country:'Italy'},
  NAP:{city:'Naples',airport:'Naples International',country:'Italy'},
  BRI:{city:'Bari',airport:'Karol Wojtyla Airport',country:'Italy'},
  CTA:{city:'Catania',airport:'Fontanarossa Airport',country:'Italy'},
  PMO:{city:'Palermo',airport:'Falcone Borsellino',country:'Italy'},
  BLQ:{city:'Bologna',airport:'Guglielmo Marconi',country:'Italy'},
  TRN:{city:'Turin',airport:'Turin Airport',country:'Italy'},
  PSA:{city:'Pisa',airport:'Galileo Galilei Airport',country:'Italy'},
  BCN:{city:'Barcelona',airport:'El Prat Airport',country:'Spain'},
  MAD:{city:'Madrid',airport:'Barajas Airport',country:'Spain'},
  AGP:{city:'Malaga',airport:'Costa del Sol Airport',country:'Spain'},
  ALC:{city:'Alicante',airport:'Alicante-Elche Airport',country:'Spain'},
  PMI:{city:'Palma',airport:'Son Sant Joan',country:'Spain'},
  VLC:{city:'Valencia',airport:'Valencia Airport',country:'Spain'},
  BER:{city:'Berlin',airport:'Brandenburg Airport',country:'Germany'},
  CGN:{city:'Cologne',airport:'Cologne Bonn Airport',country:'Germany'},
  DUS:{city:'Dusseldorf',airport:'Dusseldorf Airport',country:'Germany'},
  FRA:{city:'Frankfurt',airport:'Frankfurt Airport',country:'Germany'},
  HAM:{city:'Hamburg',airport:'Hamburg Airport',country:'Germany'},
  MUC:{city:'Munich',airport:'Franz Josef Strauss',country:'Germany'},
  NUE:{city:'Nuremberg',airport:'Nuremberg Airport',country:'Germany'},
  STR:{city:'Stuttgart',airport:'Stuttgart Airport',country:'Germany'},
  FMM:{city:'Memmingen',airport:'Allgau Airport',country:'Germany'},
  DTM:{city:'Dortmund',airport:'Dortmund Airport',country:'Germany'},
  WAW:{city:'Warsaw',airport:'Chopin Airport',country:'Poland'},
  WMI:{city:'Warsaw',airport:'Modlin Airport',country:'Poland'},
  KRK:{city:'Krakow',airport:'John Paul II Airport',country:'Poland'},
  KTW:{city:'Katowice',airport:'Pyrzowice Airport',country:'Poland'},
  GDN:{city:'Gdansk',airport:'Lech Walesa Airport',country:'Poland'},
  POZ:{city:'Poznan',airport:'Lawica Airport',country:'Poland'},
  WRO:{city:'Wroclaw',airport:'Copernicus Airport',country:'Poland'},
  OTP:{city:'Bucharest',airport:'Henri Coanda Airport',country:'Romania'},
  CLJ:{city:'Cluj-Napoca',airport:'Avram Iancu Airport',country:'Romania'},
  TSR:{city:'Timisoara',airport:'Traian Vuia Airport',country:'Romania'},
  IAS:{city:'Iasi',airport:'Iasi Airport',country:'Romania'},
  SBZ:{city:'Sibiu',airport:'Sibiu Airport',country:'Romania'},
  BUD:{city:'Budapest',airport:'Ferenc Liszt Airport',country:'Hungary'},
  VIE:{city:'Vienna',airport:'Vienna International',country:'Austria'},
  ATH:{city:'Athens',airport:'Eleftherios Venizelos',country:'Greece'},
  SKG:{city:'Thessaloniki',airport:'Macedonia Airport',country:'Greece'},
  HER:{city:'Heraklion',airport:'Nikos Kazantzakis',country:'Greece'},
  RHO:{city:'Rhodes',airport:'Diagoras Airport',country:'Greece'},
  CFU:{city:'Corfu',airport:'Ioannis Kapodistrias',country:'Greece'},
  LCA:{city:'Larnaca',airport:'Larnaca Airport',country:'Cyprus'},
  PFO:{city:'Paphos',airport:'Paphos Airport',country:'Cyprus'},
  SOF:{city:'Sofia',airport:'Sofia Airport',country:'Bulgaria'},
  VAR:{city:'Varna',airport:'Varna Airport',country:'Bulgaria'},
  CDG:{city:'Paris',airport:'Charles de Gaulle',country:'France'},
  ORY:{city:'Paris',airport:'Orly Airport',country:'France'},
  BVA:{city:'Paris',airport:'Beauvais-Tille',country:'France'},
  NCE:{city:'Nice',airport:'Cote d Azur Airport',country:'France'},
  LIS:{city:'Lisbon',airport:'Humberto Delgado',country:'Portugal'},
  OPO:{city:'Porto',airport:'Francisco Sa Carneiro',country:'Portugal'},
  FAO:{city:'Faro',airport:'Faro Airport',country:'Portugal'},
  AMS:{city:'Amsterdam',airport:'Schiphol Airport',country:'Netherlands'},
  EIN:{city:'Eindhoven',airport:'Eindhoven Airport',country:'Netherlands'},
  BRU:{city:'Brussels',airport:'Brussels Airport',country:'Belgium'},
  CRL:{city:'Brussels',airport:'Charleroi Airport',country:'Belgium'},
  ARN:{city:'Stockholm',airport:'Arlanda Airport',country:'Sweden'},
  GOT:{city:'Gothenburg',airport:'Landvetter Airport',country:'Sweden'},
  CPH:{city:'Copenhagen',airport:'Kastrup Airport',country:'Denmark'},
  OSL:{city:'Oslo',airport:'Gardermoen Airport',country:'Norway'},
  HEL:{city:'Helsinki',airport:'Helsinki-Vantaa',country:'Finland'},
  BEG:{city:'Belgrade',airport:'Nikola Tesla Airport',country:'Serbia'},
  PRN:{city:'Pristina',airport:'Adem Jashari Airport',country:'Kosovo'},
  SKP:{city:'Skopje',airport:'Skopje Airport',country:'North Macedonia'},
  TGD:{city:'Podgorica',airport:'Podgorica Airport',country:'Montenegro'},
  ZAG:{city:'Zagreb',airport:'Franjo Tudman Airport',country:'Croatia'},
  SPU:{city:'Split',airport:'Split Airport',country:'Croatia'},
  DBV:{city:'Dubrovnik',airport:'Dubrovnik Airport',country:'Croatia'},
  TIA:{city:'Tirana',airport:'Mother Teresa Airport',country:'Albania'},
  PRG:{city:'Prague',airport:'Vaclav Havel Airport',country:'Czechia'},
  BTS:{city:'Bratislava',airport:'M.R. Stefanik Airport',country:'Slovakia'},
  LJU:{city:'Ljubljana',airport:'Joze Pucnik Airport',country:'Slovenia'},
  RIX:{city:'Riga',airport:'Riga Airport',country:'Latvia'},
  VNO:{city:'Vilnius',airport:'Vilnius Airport',country:'Lithuania'},
  TLL:{city:'Tallinn',airport:'Lennart Meri Airport',country:'Estonia'},
  KIV:{city:'Chisinau',airport:'Chisinau Airport',country:'Moldova'},
  SJJ:{city:'Sarajevo',airport:'Sarajevo Airport',country:'Bosnia'}
};

// State
let logs = [];
let searching = false;
let paused = false;
let stopped = false;
let cookieJar = '';
let xsrfToken = '';
let searchResults = [];
let currentSort = { field: null, asc: true };
let allDestinationsForReturn = new Set();
let verboseMode = true;

// Helpers
const $ = id => document.getElementById(id);
const $$ = s => document.querySelectorAll(s);

function L(m, c = '') {
  const ts = new Date().toISOString().slice(11, 23);
  const l = `[${ts}] ${m}`;
  logs.push({ l, c, ts: Date.now() });
  if (logs.length > 5000) logs = logs.slice(-5000);
  console.log('[AYCF]', m);
  const a = $('logArea');
  if (a) {
    const d = document.createElement('div');
    d.className = c;
    d.textContent = l;
    a.appendChild(d);
    a.scrollTop = a.scrollHeight;
  }
  $('lCnt').textContent = `(${logs.length})`;
}
function LE(m) { L('âŒ ERROR: ' + m, 'e'); }
function LW(m) { L('âš ï¸ WARN: ' + m, 'w'); }
function LS(m) { L('âœ… SUCCESS: ' + m, 's'); }
function LA(m) { L('ğŸŒ API: ' + m, 'a'); }
function LV(m) { if (verboseMode) L('ğŸ” VERBOSE: ' + m, 'v'); }

function getAirportInfo(code) {
  const info = AIRPORTS[code];
  if (info) return { code, ...info };
  return { code, city: code, airport: code, country: 'Unknown' };
}

function formatDate(d) {
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
}

function formatDateDMY(dateStr) {
  if (!dateStr) return '--/--/----';
  const [y, m, d] = dateStr.split('-');
  return `${d}/${m}/${y}`;
}

function updateDateDisplay() {
  const dateVal = $('filterDate').value;
  $('dateDisplay').textContent = formatDateDMY(dateVal);
}

function formatDateTime(dt, tm) {
  if (!dt) return '';
  const [y, m, d] = dt.split('-');
  const time = tm ? formatTime(tm) : '00:00';
  return `${time} ${d}/${m}/${y}`;
}

function formatTime(t) {
  if (!t || t === 'undefined' || t === 'null') return '--:--';

  // Handle ISO datetime: "2026-02-03T07:30:00"
  if (t.includes('T')) t = t.split('T')[1];

  // Remove timezone: "07:30:00+02:00" or "Z"
  if (t.includes('+')) t = t.split('+')[0];
  if (t.includes('Z')) t = t.replace('Z', '');

  if (t.includes(':')) {
    const parts = t.split(':');
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);

    if (isNaN(hours)) return '--:--';
    if (isNaN(minutes)) return String(hours).padStart(2, '0') + ':00';

    return String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0');
  }

  return '--:--';
}

function addDays(dateStr, days) {
  const [y, m, d] = dateStr.split('-').map(Number);
  const date = new Date(y, m - 1, d);
  date.setDate(date.getDate() + days);
  return formatDate(date);
}

// Group results by destination city for round trip display
function groupByDestination(results) {
  const groups = new Map();
  results.forEach(flight => {
    // For outbound: group by destination city
    // For return: group by origin city (which was our outbound destination)
    const key = flight.type === 'outbound' ? flight.destCity : flight.originCity;
    const country = flight.type === 'outbound' ? flight.destCountry : flight.originCountry;

    if (!groups.has(key)) {
      groups.set(key, {
        city: key,
        country: country,
        outbound: [],
        returns: []
      });
    }

    if (flight.type === 'outbound') {
      groups.get(key).outbound.push(flight);
    } else {
      groups.get(key).returns.push(flight);
    }
  });
  return groups;
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
function getProxy() { return localStorage.getItem('wz_proxy') || ''; }
function getPriorityCities() {
  const saved = localStorage.getItem('wz_priority_cities') || 'TLV';
  return saved.split(',').map(c => c.trim().toUpperCase()).filter(c => c.length === 3);
}

function bookingUrl(o, d, dt) {
  return `https://multipass.wizzair.com/en/w6/subscriptions/spa/private-page/flight-search?origin=${o}&destination=${d}&departureDate=${dt}`;
}

// Credentials
function saveCredentials() {
  if ($('saveCredentials').checked) {
    const email = $('wizEmail').value.trim();
    const pass = $('wizPass').value;
    if (email && pass) {
      localStorage.setItem('wz_email', btoa(email));
      localStorage.setItem('wz_pass', btoa(pass));
      LV('Credentials saved to localStorage');
    }
  }
}

function loadCredentials() {
  try {
    const email = localStorage.getItem('wz_email');
    const pass = localStorage.getItem('wz_pass');
    if (email && pass) {
      $('wizEmail').value = atob(email);
      $('wizPass').value = atob(pass);
      $('saveCredentials').checked = true;
      LV('Credentials loaded from localStorage');
    }
  } catch (e) {
    LW('Failed to load credentials: ' + e.message);
  }
}

function clearCredentials() {
  localStorage.removeItem('wz_email');
  localStorage.removeItem('wz_pass');
  $('wizEmail').value = '';
  $('wizPass').value = '';
  $('saveCredentials').checked = false;
  LS('Credentials cleared');
}

// Multi-select chip rendering
function updateChips(selectId, chipsId) {
  const select = $(selectId);
  const chipsDiv = $(chipsId);
  const selected = Array.from(select.selectedOptions).map(o => ({ value: o.value, text: o.text }));

  chipsDiv.innerHTML = selected.map(s =>
    `<span class="chip" data-value="${s.value}">${s.text} <span class="x" data-value="${s.value}">Ã—</span></span>`
  ).join('');

  chipsDiv.querySelectorAll('.x').forEach(x => {
    x.onclick = (e) => {
      e.stopPropagation();
      const val = x.dataset.value;
      Array.from(select.options).forEach(o => {
        if (o.value === val) o.selected = false;
      });
      updateChips(selectId, chipsId);
    };
  });
}

// Populate dropdowns
function populateCityDropdowns() {
  const cities = new Map();
  Object.entries(AIRPORTS).forEach(([code, info]) => {
    const key = `${info.city}, ${info.country}`;
    if (!cities.has(key)) cities.set(key, []);
    cities.get(key).push(code);
  });

  const priorityCodes = getPriorityCities();
  const sortedCities = [...cities.entries()].sort((a, b) => {
    const aHasPriority = a[1].some(c => priorityCodes.includes(c));
    const bHasPriority = b[1].some(c => priorityCodes.includes(c));
    if (aHasPriority && !bHasPriority) return -1;
    if (!aHasPriority && bHasPriority) return 1;
    return a[0].localeCompare(b[0]);
  });

  const originSel = $('filterOrigin');
  originSel.innerHTML = sortedCities.map(([city, codes]) =>
    `<option value="${codes.join(',')}">${city} (${codes.join('/')})</option>`
  ).join('');

  // Pre-select TLV
  Array.from(originSel.options).forEach(o => {
    if (o.value.includes('TLV')) o.selected = true;
  });
  updateChips('filterOrigin', 'originChips');

  const destSel = $('filterDest');
  destSel.innerHTML = sortedCities.map(([city, codes]) =>
    `<option value="${codes.join(',')}">${city} (${codes.join('/')})</option>`
  ).join('');
  updateChips('filterDest', 'destChips');
}

// Proxy fetch with verbose logging
async function px(url, opts = {}) {
  const proxy = getProxy();
  if (!proxy) throw new Error('Proxy not configured');

  LV(`px() called for: ${url}`);
  LV(`Options: method=${opts.method || 'GET'}, hasBody=${!!opts.body}`);

  const maxRedirects = opts.maxRedirects || 5;
  let currentUrl = url;
  let attempt = 0;

  while (attempt < maxRedirects) {
    attempt++;
    const headers = { 'X-Target': currentUrl };
    if (cookieJar) {
      headers['X-Cookies'] = cookieJar;
      LV(`Sending ${cookieJar.split(';').length} cookies`);
    }
    if (opts.contentType) headers['Content-Type'] = opts.contentType;
    if (xsrfToken) {
      headers['X-XSRF-TOKEN'] = xsrfToken;
      LV(`XSRF token: ${xsrfToken.substring(0, 20)}...`);
    }

    const fOpts = { method: (attempt === 1 ? opts.method : null) || 'GET', headers };
    if (attempt === 1 && opts.body) {
      fOpts.body = typeof opts.body === 'string' ? opts.body : JSON.stringify(opts.body);
      LV(`Request body: ${fOpts.body.substring(0, 200)}...`);
    }

    LA(`[${attempt}/${maxRedirects}] ${fOpts.method} ${currentUrl.substring(0, 100)}...`);

    let resp;
    try {
      resp = await fetch(proxy, fOpts);
    } catch (fetchErr) {
      LE(`Fetch failed: ${fetchErr.message}`);
      throw fetchErr;
    }

    LV(`Response status: ${resp.status}`);
    LV(`Response headers: ${[...resp.headers.entries()].map(([k,v]) => `${k}=${v.substring(0,50)}`).join(', ')}`);

    const sc = resp.headers.get('X-Set-Cookies');
    if (sc) {
      try {
        const arr = JSON.parse(sc);
        LV(`Received ${arr.length} Set-Cookie headers`);
        arr.forEach(c => {
          const parts = c.split(';')[0];
          const [name] = parts.split('=');
          const existing = cookieJar.split('; ').filter(x => x && !x.startsWith(name.trim() + '='));
          existing.push(parts);
          cookieJar = existing.join('; ');
          if (name.trim() === 'XSRF-TOKEN') {
            xsrfToken = decodeURIComponent(parts.split('=').slice(1).join('='));
            LV(`Got XSRF token: ${xsrfToken.substring(0, 30)}...`);
          }
        });
      } catch (e) {
        LW(`Failed to parse Set-Cookie: ${e.message}`);
      }
    }

    const loc = resp.headers.get('X-Location');
    const xStatus = resp.headers.get('X-Status');

    if (loc) {
      LV(`Redirect ${xStatus || '3xx'} -> ${loc}`);
      if (loc.startsWith('/')) currentUrl = new URL(currentUrl).origin + loc;
      else if (loc.startsWith('http')) currentUrl = loc;
      else currentUrl = new URL(loc, currentUrl).href;
      continue;
    }

    const status = parseInt(xStatus) || resp.status;
    const bodyText = await resp.text();

    L(`  âœ“ HTTP ${status} | ${bodyText.length} bytes`);
    LV(`Response body preview: ${bodyText.substring(0, 500)}...`);

    return {
      status,
      headers: resp.headers,
      url: currentUrl,
      bodyText,
      json: () => {
        try {
          const parsed = JSON.parse(bodyText);
          LV(`Parsed JSON successfully, keys: ${Object.keys(parsed).join(', ')}`);
          return parsed;
        } catch(e) {
          LW(`JSON parse failed: ${e.message}`);
          LV(`Raw body that failed to parse: ${bodyText.substring(0, 1000)}`);
          return null;
        }
      }
    };
  }
  throw new Error('Too many redirects');
}

// Worker code
function workerCode() {
  return `export default{
async fetch(r,env,ctx){
const cors={'Access-Control-Allow-Origin':'*',
'Access-Control-Allow-Methods':'GET,POST,PUT,DELETE,OPTIONS',
'Access-Control-Allow-Headers':'Content-Type,X-Target,X-Cookies,X-XSRF-TOKEN',
'Access-Control-Expose-Headers':'X-Set-Cookies,X-Location,Content-Type,X-Status',
'Access-Control-Max-Age':'86400'};
if(r.method==='OPTIONS')return new Response(null,{headers:cors});
const t=r.headers.get('X-Target');
if(!t)return new Response(JSON.stringify({error:'Need X-Target header'}),{status:400,headers:{...cors,'Content-Type':'application/json'}});
let url;try{url=new URL(t)}catch{return new Response(JSON.stringify({error:'Invalid URL'}),{status:400,headers:{...cors,'Content-Type':'application/json'}})}
if(!url.hostname.endsWith('wizzair.com'))return new Response(JSON.stringify({error:'Only wizzair.com'}),{status:403,headers:{...cors,'Content-Type':'application/json'}});
const h=new Headers();
h.set('User-Agent','Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
h.set('Accept','text/html,application/xhtml+xml,application/json,*/*;q=0.8');
h.set('Accept-Language','en-US,en;q=0.9');
if(r.headers.get('Content-Type'))h.set('Content-Type',r.headers.get('Content-Type'));
const ck=r.headers.get('X-Cookies');if(ck)h.set('Cookie',ck);
const xsrf=r.headers.get('X-XSRF-TOKEN');if(xsrf)h.set('X-XSRF-TOKEN',xsrf);
h.set('Referer','https://multipass.wizzair.com/');
h.set('Origin','https://multipass.wizzair.com');
try{
const resp=await fetch(t,{method:r.method,headers:h,body:['GET','HEAD'].includes(r.method)?undefined:await r.arrayBuffer(),redirect:'manual'});
const rh=new Headers(cors);
rh.set('X-Status',String(resp.status));
const sc=resp.headers.getSetCookie?resp.headers.getSetCookie():[];
if(sc.length)rh.set('X-Set-Cookies',JSON.stringify(sc));
if(resp.status>=300&&resp.status<400){
rh.set('X-Location',resp.headers.get('Location')||'');
return new Response(JSON.stringify({redirect:resp.headers.get('Location')}),{status:200,headers:rh})}
const ct=resp.headers.get('Content-Type');if(ct)rh.set('Content-Type',ct);
return new Response(resp.body,{status:resp.status,headers:rh});
}catch(e){return new Response(JSON.stringify({error:e.message}),{status:502,headers:{...cors,'Content-Type':'application/json'}})}
}};`;
}

function showMsg(type, msg) {
  const c = { s: 'mg-s', e: 'mg-e', w: 'mg-w', i: 'mg-i' };
  $('loginMsg').innerHTML = `<div class="mg ${c[type] || 'mg-i'}">${msg}</div>`;
  if (type !== 'e') setTimeout(() => { $('loginMsg').innerHTML = ''; }, 8000);
}

function setProgress(p) { $('dlFill').style.width = Math.min(100, p) + '%'; }
function showStatus(m) { $('dlStatus').textContent = m; }

// Render results - supports both flat and grouped (round trip) display
function renderResults() {
  const area = $('resultsArea');
  $('resultsCount').textContent = `${searchResults.length} flights`;

  if (!searchResults.length) {
    area.innerHTML = '<div class="mg mg-w">No flights found yet.</div>';
    return;
  }

  // Check if we have round trip results (both outbound and return)
  const hasRoundTrip = searchResults.some(r => r.type === 'return');

  if (hasRoundTrip) {
    renderGroupedResults(area);
  } else {
    renderFlatResults(area);
  }
}

// Render results grouped by destination city (for round trips)
function renderGroupedResults(area) {
  const groups = groupByDestination(searchResults);
  let html = '';

  // Get the origin city from the first outbound flight
  const firstOutbound = searchResults.find(r => r.type === 'outbound');
  const originCity = firstOutbound ? firstOutbound.originCity : 'Origin';

  // Count valid round trips (destinations with BOTH outbound AND return)
  let validGroups = 0;

  groups.forEach((group, cityName) => {
    // ONLY show groups that have BOTH outbound AND return flights
    // Skip destinations with only one leg - not a valid round trip
    if (group.outbound.length === 0 || group.returns.length === 0) {
      return; // Skip this destination
    }

    validGroups++;

    html += `<div style="margin-bottom:20px;border:1px solid var(--bdr);border-radius:var(--r);overflow:hidden;">`;
    html += `<div style="background:var(--s2);padding:12px 16px;border-bottom:1px solid var(--bdr);">`;
    html += `<span style="font-size:1rem;font-weight:700;color:var(--acc);">`;
    html += `ğŸ”„ Round Trip: ${originCity} â†” ${group.city}, ${group.country}</span>`;
    html += `<span style="margin-left:16px;font-size:.78rem;color:var(--tx2);">`;
    html += `${group.outbound.length} outbound, ${group.returns.length} return</span>`;
    html += `</div>`;

    // Outbound flights section
    html += `<div style="padding:12px 16px;">`;
    html += `<div style="font-weight:600;color:var(--tx2);font-size:.78rem;margin-bottom:8px;">âœˆï¸ Outbound Flights (${originCity} â†’ ${group.city})</div>`;
    html += renderFlightTable(group.outbound);
    html += `</div>`;

    // Return flights section
    html += `<div style="padding:12px 16px;border-top:1px solid var(--bdr);background:var(--s1);">`;
    html += `<div style="font-weight:600;color:var(--tx2);font-size:.78rem;margin-bottom:8px;">â†©ï¸ Return Flights (${group.city} â†’ ${originCity})</div>`;
    html += renderFlightTable(group.returns);
    html += `</div>`;

    html += `</div>`;
  });

  // If no valid round trips found, show message
  if (validGroups === 0) {
    html = '<div class="mg mg-w">No complete round trips found. Try expanding your date range or destinations.</div>';
  }

  area.innerHTML = html;
}

// Render a simple table for a list of flights (used in grouped view)
function renderFlightTable(flights) {
  let html = '<div class="tbl-wrap"><table><thead><tr>';
  html += '<th>Date</th><th>Departure</th><th>Arrival</th><th>Flight #</th><th>Book</th>';
  html += '</tr></thead><tbody>';

  flights.sort((a, b) => a.date.localeCompare(b.date) || (a.departure || '').localeCompare(b.departure || ''));

  flights.forEach(f => {
    html += `<tr>`;
    html += `<td class="mono">${formatDateDMY(f.date)}</td>`;
    html += `<td class="mono">${formatTime(f.departure)}</td>`;
    html += `<td class="mono">${formatTime(f.arrival)}</td>`;
    html += `<td class="mono">${f.flightNumber || '-'}</td>`;
    html += `<td><a href="${f.bookingUrl}" target="_blank" class="link-btn">Book</a></td>`;
    html += `</tr>`;
  });

  html += '</tbody></table></div>';
  return html;
}

// Render flat results table (for one-way flights)
function renderFlatResults(area) {
  let sorted = [...searchResults];
  if (currentSort.field) {
    sorted.sort((a, b) => {
      let va = a[currentSort.field] || '';
      let vb = b[currentSort.field] || '';
      if (typeof va === 'string') va = va.toLowerCase();
      if (typeof vb === 'string') vb = vb.toLowerCase();
      if (va < vb) return currentSort.asc ? -1 : 1;
      if (va > vb) return currentSort.asc ? 1 : -1;
      return 0;
    });
  }

  const columns = [
    { key: 'type', label: 'Type' },
    { key: 'originCountry', label: 'Origin Country' },
    { key: 'originCity', label: 'Origin City' },
    { key: 'originAirport', label: 'Origin Airport' },
    { key: 'destCountry', label: 'Dest Country' },
    { key: 'destCity', label: 'Dest City' },
    { key: 'destAirport', label: 'Dest Airport' },
    { key: 'flightNumber', label: 'Flight #' },
    { key: 'date', label: 'Date' },
    { key: 'departure', label: 'Departure' },
    { key: 'arrival', label: 'Arrival' },
    { key: 'bookingUrl', label: 'Book' }
  ];

  let html = '<div class="tbl-wrap"><table><thead><tr>';
  columns.forEach(col => {
    const sortClass = currentSort.field === col.key ? (currentSort.asc ? 'sorted-asc' : 'sorted-desc') : '';
    html += `<th class="${sortClass}" data-sort="${col.key}">${col.label}`;
    if (col.key !== 'bookingUrl') {
      html += `<span class="th-filter"><input type="text" data-filter="${col.key}" placeholder="Filter..."></span>`;
    }
    html += '</th>';
  });
  html += '</tr></thead><tbody>';

  sorted.forEach((r, idx) => {
    html += `<tr data-idx="${idx}">
      <td>${r.type === 'return' ? 'â†©ï¸ Return' : 'âœˆï¸ Outbound'}</td>
      <td>${r.originCountry}</td>
      <td>${r.originCity}</td>
      <td>${r.originAirport} (${r.originCode})</td>
      <td>${r.destCountry}</td>
      <td>${r.destCity}</td>
      <td>${r.destAirport} (${r.destCode})</td>
      <td class="mono">${r.flightNumber || '-'}</td>
      <td class="mono">${formatDateDMY(r.date)}</td>
      <td class="mono">${formatTime(r.departure)}</td>
      <td class="mono">${formatTime(r.arrival)}</td>
      <td><a href="${r.bookingUrl}" target="_blank" class="link-btn">Book</a></td>
    </tr>`;
  });
  html += '</tbody></table></div>';
  area.innerHTML = html;

  // Sort handlers
  area.querySelectorAll('th[data-sort]').forEach(th => {
    th.addEventListener('click', e => {
      if (e.target.tagName === 'INPUT') return;
      const field = th.dataset.sort;
      if (field === 'bookingUrl') return;
      if (currentSort.field === field) currentSort.asc = !currentSort.asc;
      else { currentSort.field = field; currentSort.asc = true; }
      renderResults();
    });
  });

  // Filter handlers
  area.querySelectorAll('input[data-filter]').forEach(inp => {
    inp.addEventListener('input', () => {
      const filters = {};
      area.querySelectorAll('input[data-filter]').forEach(i => {
        if (i.value.trim()) filters[i.dataset.filter] = i.value.trim().toLowerCase();
      });
      area.querySelectorAll('tbody tr').forEach(tr => {
        const idx = parseInt(tr.dataset.idx);
        const row = searchResults[idx];
        let show = true;
        for (const [key, val] of Object.entries(filters)) {
          const cellVal = String(row[key] || '').toLowerCase();
          if (!cellVal.includes(val)) { show = false; break; }
        }
        tr.style.display = show ? '' : 'none';
      });
    });
  });
}

function addFlightResult(flight) {
  searchResults.push(flight);
  $('resultsCount').textContent = `${searchResults.length} flights`;
  if (searchResults.length <= 3 || searchResults.length % 10 === 0) renderResults();
}

// Main search function
async function searchFlights() {
  if (searching) return;

  L('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  L('STARTING NEW SEARCH');
  L('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

  const email = $('wizEmail').value.trim();
  const pass = $('wizPass').value;

  LV(`Email: ${email}`);
  LV(`Password: ${'*'.repeat(pass.length)}`);
  LV(`Proxy: ${getProxy()}`);

  if (!email || !pass) { showMsg('e', 'Enter email and password.'); return; }
  if (!getProxy()) { showMsg('e', 'Set up proxy first.'); return; }

  saveCredentials();

  const filterDate = $('filterDate').value;
  const filterDateFlex = $('filterDateFlex').value;

  // Get selected origins and destinations
  const originSel = $('filterOrigin');
  const destSel = $('filterDest');

  const selectedOrigins = Array.from(originSel.selectedOptions).flatMap(o => o.value.split(','));
  const selectedDests = Array.from(destSel.selectedOptions).flatMap(o => o.value.split(','));

  const isRoundTrip = $('filterRoundTrip').value === 'yes';

  L(`Filter date: ${filterDate} (flex: ${filterDateFlex})`);
  L(`Selected origins: ${selectedOrigins.join(', ')}`);
  L(`Selected destinations: ${selectedDests.length ? selectedDests.join(', ') : 'ALL'}`);
  L(`Round trip: ${isRoundTrip}`);

  if (!filterDate) { showMsg('e', 'Select departure date.'); return; }
  if (!selectedOrigins.length) { showMsg('e', 'Select at least one origin city.'); return; }

  searching = true;
  paused = false;
  stopped = false;
  cookieJar = '';
  xsrfToken = '';
  searchResults = [];
  allDestinationsForReturn = new Set();
  let foundDestinationsWithFlights = new Set();  // Track destinations where outbound flights were actually found
  verboseMode = $('verboseLog').checked;

  $('bSearch').disabled = true;
  $('bPause').classList.remove('hd-n');
  $('bStop').classList.remove('hd-n');
  $('bResume').classList.add('hd-n');
  $('dlProg').classList.remove('hd-n');
  showStatus('Connecting...');
  setProgress(0);
  renderResults();

  try {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 1: Get Login Page
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    L('');
    L('â•â•â• STEP 1: GET LOGIN PAGE â•â•â•');
    showStatus('Getting login page...');

    const loginR = await px('https://multipass.wizzair.com/w6/subscriptions/auth/login', { maxRedirects: 10 });

    LV(`Final URL after redirects: ${loginR.url}`);
    LV(`Body length: ${loginR.bodyText.length}`);

    const isKeycloak = loginR.url.includes('/auth/realms/') || loginR.bodyText.includes('kc-form-login');
    L(`Is Keycloak login page: ${isKeycloak}`);

    if (!isKeycloak) {
      LE('Did not reach Keycloak login page');
      LV(`URL: ${loginR.url}`);
      LV(`Body contains "login": ${loginR.bodyText.includes('login')}`);
      LV(`Body contains "form": ${loginR.bodyText.includes('form')}`);
      throw new Error('Could not reach login page');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 2: Submit Credentials
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    L('');
    L('â•â•â• STEP 2: SUBMIT CREDENTIALS â•â•â•');
    showStatus('Logging in...');

    const formMatch = loginR.bodyText.match(/<form[^>]*id="kc-form-login"[^>]*action="([^"]+)"/i) ||
                      loginR.bodyText.match(/<form[^>]*action="([^"]*login-actions[^"]*)"/i);

    if (!formMatch) {
      LE('Could not find login form action');
      LV(`Looking for form in body...`);
      const formTags = loginR.bodyText.match(/<form[^>]*>/gi) || [];
      LV(`Found ${formTags.length} form tags: ${formTags.join('\n')}`);
      throw new Error('Login form not found');
    }

    let formAction = formMatch[1].replace(/&amp;/g, '&');
    L(`Form action found: ${formAction}`);

    if (formAction.startsWith('/')) {
      formAction = 'https://multipass.wizzair.com' + formAction;
    }
    L(`Full form action URL: ${formAction}`);

    const authR = await px(formAction, {
      method: 'POST',
      contentType: 'application/x-www-form-urlencoded',
      body: `username=${encodeURIComponent(email)}&password=${encodeURIComponent(pass)}&credentialId=`,
      maxRedirects: 10
    });

    LV(`Auth response URL: ${authR.url}`);
    LV(`Auth response length: ${authR.bodyText.length}`);

    if (authR.bodyText.includes('Invalid username or password') || authR.bodyText.includes('Invalid credentials')) {
      LE('Invalid credentials detected in response');
      throw new Error('Invalid username or password');
    }

    const stillOnLogin = authR.url.includes('/auth/realms/') && authR.url.includes('login');
    L(`Still on login page: ${stillOnLogin}`);

    if (stillOnLogin) {
      LW('May still be on login page - checking for errors...');
      const errorMatch = authR.bodyText.match(/class="[^"]*error[^"]*"[^>]*>([^<]+)/i) ||
                        authR.bodyText.match(/pf-c-alert[^>]*>[\s\S]*?<[^>]*>([^<]+)/i);
      if (errorMatch) {
        LE(`Login error found: ${errorMatch[1]}`);
        throw new Error(errorMatch[1]);
      }
    }

    LS('Login appears successful!');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 3: Parse Routes from Response
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    L('');
    L('â•â•â• STEP 3: PARSE ROUTES â•â•â•');
    showStatus('Parsing routes...');

    let pageHtml = authR.bodyText;

    // Check if we need to fetch the wallets page
    if (pageHtml.length < 50000 || !pageHtml.includes('"routes"')) {
      L('Response too small or missing routes, fetching wallets page...');
      const walletsR = await px('https://multipass.wizzair.com/w6/subscriptions/spa/private-page/wallets', { maxRedirects: 10 });
      pageHtml = walletsR.bodyText;
      L(`Wallets page size: ${pageHtml.length} bytes`);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Extract dynamic search URL with session-specific UUID
    // (Like the Chrome extension does in content.js)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    L('');
    L('â•â•â• EXTRACTING DYNAMIC SEARCH URL â•â•â•');
    dynamicSearchUrl = null;

    // Extract UUID from any availability URL in page and build correct JSON API URL
    // The Chrome extension does this: extracts UUID, then builds /w6/subscriptions/json/availability/{uuid}
    // Critical: NO /en/ prefix, and must use /json/availability/ path

    // Method 1: Extract UUID from any availability URL pattern (most common)
    const uuidMatch = pageHtml.match(/\/availability\/([a-f0-9-]{36})/i);
    if (uuidMatch && uuidMatch[1]) {
      const uuid = uuidMatch[1];
      dynamicSearchUrl = `https://multipass.wizzair.com/w6/subscriptions/json/availability/${uuid}`;
      L(`Found UUID: ${uuid}`);
      L(`Built JSON search URL: ${dynamicSearchUrl}`);
    }

    // Method 2: Look for CVO.flightSearchUrlJson and extract UUID
    if (!dynamicSearchUrl) {
      const cvoMatch = pageHtml.match(/flightSearchUrlJson[^"]*"https:\/\/multipass\.wizzair\.com[^"]*\/([a-f0-9-]{36})"/i);
      if (cvoMatch && cvoMatch[1]) {
        const uuid = cvoMatch[1];
        dynamicSearchUrl = `https://multipass.wizzair.com/w6/subscriptions/json/availability/${uuid}`;
        L(`Found UUID (method 2 - CVO): ${uuid}`);
        L(`Built JSON search URL: ${dynamicSearchUrl}`);
      }
    }

    if (dynamicSearchUrl) {
      L(`âœ“ Dynamic search URL ready: ${dynamicSearchUrl}`);
    } else {
      LW('Could not find dynamic search URL in page - will try fallback endpoint');
    }

    // Try to find routes
    let routes = [];

    // First, check if we got valid HTML/JSON
    L(`Page content type check:`);
    L(`  - Starts with '<': ${pageHtml.trim().startsWith('<')}`);
    L(`  - Starts with '{': ${pageHtml.trim().startsWith('{')}`);
    L(`  - Contains 'routes': ${pageHtml.includes('routes')}`);
    L(`  - Contains 'subscription': ${pageHtml.includes('subscription')}`);
    L(`  - Contains 'AYCF': ${pageHtml.includes('AYCF')}`);

    // Method 1: Standard "routes" array
    L('Trying Method 1: Standard "routes" array...');
    const routesMatch = pageHtml.match(/"routes"\s*:\s*(\[[\s\S]*?\])(?=\s*[,}])/);
    if (routesMatch) {
      try {
        routes = JSON.parse(routesMatch[1]);
        L(`Method 1 SUCCESS: Found ${routes.length} routes`);
        LV(`First route: ${JSON.stringify(routes[0])}`);
      } catch (e) {
        LW(`Method 1 FAILED: ${e.message}`);
      }
    } else {
      L('Method 1: No "routes" pattern found');
    }

    // Method 2: Look for departureStation/arrivalStations pattern
    if (!routes.length) {
      L('Trying Method 2: departureStation/arrivalStations pattern...');
      const stationPattern = /"departureStation"\s*:\s*(\{[^}]+\})\s*,\s*"arrivalStations"\s*:\s*(\[[^\]]*\])/g;
      let match;
      while ((match = stationPattern.exec(pageHtml)) !== null) {
        try {
          const dep = JSON.parse(match[1]);
          const arr = JSON.parse(match[2]);
          routes.push({ departureStation: dep, arrivalStations: arr });
        } catch (e) {}
      }
      if (routes.length) {
        L(`Method 2 SUCCESS: Found ${routes.length} routes`);
      } else {
        L('Method 2: No matches found');
      }
    }

    // Method 2b: Try finding routes in embedded JSON
    if (!routes.length) {
      L('Trying Method 2b: Embedded JSON with routes...');
      const jsonMatches = pageHtml.matchAll(/<script[^>]*>([^<]*"routes"[^<]*)<\/script>/gi);
      for (const jm of jsonMatches) {
        try {
          // Try to extract JSON object containing routes
          const jsonStr = jm[1].match(/\{[^{}]*"routes"\s*:\s*\[[^\]]*\][^{}]*\}/);
          if (jsonStr) {
            const parsed = JSON.parse(jsonStr[0]);
            if (parsed.routes && Array.isArray(parsed.routes)) {
              routes = parsed.routes;
              L(`Method 2b SUCCESS: Found ${routes.length} routes in script tag`);
              break;
            }
          }
        } catch (e) { }
      }
    }

    // Method 2c: Look for __NEXT_DATA__ or similar embedded state
    if (!routes.length) {
      L('Trying Method 2c: __NEXT_DATA__ or embedded state...');
      const nextDataMatch = pageHtml.match(/<script[^>]*id="__NEXT_DATA__"[^>]*>([^<]+)<\/script>/i) ||
                           pageHtml.match(/<script>window\.__INITIAL_STATE__\s*=\s*(\{[\s\S]*?\})\s*<\/script>/i);
      if (nextDataMatch) {
        try {
          const state = JSON.parse(nextDataMatch[1]);
          // Search for routes in the state object
          const findRoutes = (obj, depth = 0) => {
            if (depth > 5) return null;
            if (!obj || typeof obj !== 'object') return null;
            if (Array.isArray(obj.routes)) return obj.routes;
            for (const key of Object.keys(obj)) {
              const found = findRoutes(obj[key], depth + 1);
              if (found) return found;
            }
            return null;
          };
          const foundRoutes = findRoutes(state);
          if (foundRoutes) {
            routes = foundRoutes;
            L(`Method 2c SUCCESS: Found ${routes.length} routes in embedded state`);
          }
        } catch (e) {
          LW(`Method 2c parse error: ${e.message}`);
        }
      }
    }

    // Method 3: Extract all airport codes
    if (!routes.length) {
      L('Trying Method 3: Extract all airport codes...');
      const allCodes = new Set();
      const codeMatches = pageHtml.matchAll(/"id"\s*:\s*"([A-Z]{3})"/g);
      for (const m of codeMatches) {
        if (AIRPORTS[m[1]]) allCodes.add(m[1]);
      }

      // Also try to find codes in other formats
      const altCodeMatches = pageHtml.matchAll(/"iata"\s*:\s*"([A-Z]{3})"/g);
      for (const m of altCodeMatches) {
        if (AIRPORTS[m[1]]) allCodes.add(m[1]);
      }

      const codeOnlyMatches = pageHtml.matchAll(/"code"\s*:\s*"([A-Z]{3})"/g);
      for (const m of codeOnlyMatches) {
        if (AIRPORTS[m[1]]) allCodes.add(m[1]);
      }

      L(`Found ${allCodes.size} known airport codes: ${[...allCodes].join(', ')}`);

      if (allCodes.size > 0) {
        selectedOrigins.forEach(o => {
          const dests = [...allCodes].filter(c => c !== o);
          if (dests.length) {
            routes.push({
              departureStation: { id: o },
              arrivalStations: dests.map(c => ({ id: c }))
            });
          }
        });
        L(`Method 3: Built ${routes.length} synthetic routes`);
      }
    }

    // Method 4: Fallback - use all known airports for selected origins
    if (!routes.length) {
      L('Trying Method 4: Using all known AIRPORTS as fallback...');
      const allAirportCodes = Object.keys(AIRPORTS);
      selectedOrigins.forEach(o => {
        const dests = allAirportCodes.filter(c => c !== o);
        routes.push({
          departureStation: { id: o },
          arrivalStations: dests.map(c => ({ id: c }))
        });
      });
      L(`Method 4: Built ${routes.length} synthetic routes using ${allAirportCodes.length} airports`);
      LW('Using fallback method - may result in many "no flights" responses');
    }

    L(`Total raw routes: ${routes.length}`);

    // Parse routes into usable format
    const parsedRoutes = [];
    routes.forEach((r, idx) => {
      let origin = null, destinations = [];

      if (r.departureStation && r.departureStation.id) {
        origin = r.departureStation.id;
        destinations = (r.arrivalStations || []).map(a => typeof a === 'string' ? a : (a.id || a)).filter(Boolean);
      } else if (r.origin) {
        origin = r.origin;
        destinations = r.destinations || [];
      }

      LV(`Route ${idx}: origin=${origin}, destinations=${destinations.length}`);

      if (origin && destinations.length) {
        // Filter by selected origins
        if (!selectedOrigins.includes(origin)) {
          LV(`  Skipping - origin ${origin} not in selected: ${selectedOrigins.join(',')}`);
          return;
        }

        // Filter by selected destinations (if any)
        if (selectedDests.length > 0) {
          const before = destinations.length;
          destinations = destinations.filter(d => selectedDests.includes(d));
          LV(`  Filtered destinations: ${before} -> ${destinations.length}`);
        }

        if (destinations.length) {
          parsedRoutes.push({ origin, destinations });
          destinations.forEach(d => allDestinationsForReturn.add(d));
          LV(`  Added route: ${origin} -> ${destinations.join(', ')}`);
        }
      }
    });

    L(`Parsed routes: ${parsedRoutes.length}`);
    L(`Unique destinations for return: ${allDestinationsForReturn.size}`);

    if (!parsedRoutes.length) {
      LW('NO ROUTES MATCHED FILTERS!');
      L('This could mean:');
      L('  1. The API response format has changed');
      L('  2. Your subscription does not include selected origins');
      L('  3. There are no routes from selected origins');
      L('  4. Login may have failed silently');
      L('');
      L('Page content analysis:');
      L(`  - Contains "routes": ${pageHtml.includes('"routes"')}`);
      L(`  - Contains "departureStation": ${pageHtml.includes('departureStation')}`);
      L(`  - Contains "arrivalStations": ${pageHtml.includes('arrivalStations')}`);
      L(`  - Contains "TLV": ${pageHtml.includes('TLV')}`);
      L(`  - Contains "subscription": ${pageHtml.includes('subscription')}`);
      L(`  - Contains "wallet": ${pageHtml.includes('wallet')}`);
      L(`  - Contains "error": ${pageHtml.includes('error')}`);
      L(`  - Contains "login": ${pageHtml.includes('login')}`);
      L(`  - Page size: ${pageHtml.length} bytes`);
      L('');
      L('Looking for any JSON-like structures in the page...');

      // Try to find any JSON objects in the page
      const jsonPatterns = pageHtml.match(/\{[^{}]{50,500}\}/g) || [];
      L(`Found ${jsonPatterns.length} potential JSON structures`);
      if (jsonPatterns.length > 0 && jsonPatterns.length <= 5) {
        jsonPatterns.forEach((jp, idx) => LV(`  JSON ${idx}: ${jp.substring(0, 200)}...`));
      }

      LV(`First 3000 chars of page: ${pageHtml.substring(0, 3000)}`);
      LV(`Last 1000 chars of page: ${pageHtml.substring(pageHtml.length - 1000)}`);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 4: Search Flights
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    L('');
    L('â•â•â• STEP 4: SEARCH FLIGHTS â•â•â•');

    // Build dates - generate N days forward from selected date
    const daysAhead = parseInt(filterDateFlex, 10) || 1;
    const outboundDates = [];
    for (let i = 0; i < daysAhead; i++) {
      outboundDates.push(addDays(filterDate, i));
    }
    L(`Outbound dates (${daysAhead} days): ${outboundDates.join(', ')}`);

    const returnDates = [];
    if (isRoundTrip) {
      outboundDates.forEach(od => {
        for (let i = 3; i <= 4; i++) {
          const rd = addDays(od, i);
          if (!returnDates.includes(rd)) returnDates.push(rd);
        }
      });
      L(`Return dates: ${returnDates.join(', ')}`);
    }

    // Build tasks
    const tasks = [];
    const seen = new Set();

    parsedRoutes.forEach(r => {
      r.destinations.forEach(dest => {
        outboundDates.forEach(dt => {
          const k = `${r.origin}|${dest}|${dt}`;
          if (!seen.has(k)) {
            seen.add(k);
            tasks.push({ o: r.origin, d: dest, dt, type: 'outbound' });
          }
        });
      });
    });

    // NOTE: Return tasks are now created AFTER outbound search completes
    // Only destinations with actual flights found will be searched for returns

    L(`Total outbound tasks: ${tasks.length}`);

    if (tasks.length === 0) {
      LW('No search tasks to execute!');
      showMsg('w', 'No routes to search. Check your filter settings.');
    }

    showStatus(`Searching ${tasks.length} routes...`);

    let rateLimitCount = 0;
    let successCount = 0;
    let errorCount = 0;

    for (let i = 0; i < tasks.length; i++) {
      if (stopped) { L('Search stopped by user'); break; }
      while (paused && !stopped) { showStatus('Paused...'); await sleep(500); }
      if (stopped) break;

      const t = tasks[i];
      setProgress((i / tasks.length) * 100);
      const oInfo = getAirportInfo(t.o);
      const dInfo = getAirportInfo(t.d);
      showStatus(`${t.type === 'return' ? 'â†©ï¸' : 'âœˆï¸'} ${oInfo.city} â†’ ${dInfo.city} [${i + 1}/${tasks.length}]`);

      try {
        await sleep(300 + Math.random() * 200);

        LV(`Searching: ${t.o} -> ${t.d} on ${t.dt}`);

        // Use dynamic search URL extracted from page (with session UUID)
        // or fallback to base endpoint
        const searchUrl = dynamicSearchUrl || 'https://multipass.wizzair.com/w6/subscriptions/json/availability';
        LV(`Using search URL: ${searchUrl}`);

        // Single POST with search parameters in body (like Chrome extension)
        const r = await px(searchUrl, {
          method: 'POST',
          contentType: 'application/json',
          body: JSON.stringify({
            flightType: 'OW',
            origin: t.o,
            destination: t.d,
            departure: t.dt,
            arrival: '',
            intervalSubtype: null
          })
        });

        if (r.status === 429) {
          rateLimitCount++;
          const waitTime = rateLimitCount >= 3 ? 60000 : 15000;
          LW(`Rate limited! Waiting ${waitTime/1000}s...`);
          showStatus(`Rate limited â€” waiting ${waitTime/1000}s...`);
          await sleep(waitTime);
          if (rateLimitCount >= 3) rateLimitCount = 0;
          i--;
          continue;
        }

        rateLimitCount = 0;

        if (r.status >= 200 && r.status < 300) {
          const data = r.json();

          if (data) {
            LV(`Response data keys: ${Object.keys(data).join(', ')}`);
            LV(`Full response structure: ${JSON.stringify(data).substring(0, 1000)}`);

            // Try multiple possible flight array locations
            let fl = [];

            // Method 1: Standard responses
            if (data.flightsOutbound && Array.isArray(data.flightsOutbound)) fl = data.flightsOutbound;
            else if (data.flights && Array.isArray(data.flights)) fl = data.flights;
            else if (data.outbound && Array.isArray(data.outbound)) fl = data.outbound;
            else if (data.outboundFlights && Array.isArray(data.outboundFlights)) fl = data.outboundFlights;

            // Method 2: Direct array response
            else if (Array.isArray(data)) fl = data;

            // Method 3: Nested in result/data
            else if (data.result && Array.isArray(data.result)) fl = data.result;
            else if (data.data && Array.isArray(data.data)) fl = data.data;
            else if (data.data && data.data.flights) fl = data.data.flights;
            else if (data.response && data.response.flights) fl = data.response.flights;

            // Method 4: Check for single flight object
            else if (data.departure || data.departureTime || data.flightCode) fl = [data];

            LV(`Extracted ${fl.length} flights using parsing methods`);

            // Log the first flight structure for debugging
            if (fl.length > 0) {
              LV(`First flight object keys: ${Object.keys(fl[0]).join(', ')}`);
              LV(`First flight raw: ${JSON.stringify(fl[0])}`);
            }

            if (fl && fl.length > 0) {
              successCount++;
              L(`âœˆï¸ ${t.o} â†’ ${t.d} (${t.type}): ${fl.length} flights found`);

              // Track destinations where we actually found outbound flights (for round trip return search)
              if (t.type === 'outbound' && isRoundTrip) {
                foundDestinationsWithFlights.add(t.d);
              }

              fl.forEach(f => {
                // Try multiple field names for departure/arrival times
                const depTime = f.departure || f.departureTime || f.departureDateTime || f.depTime || f.std || '';
                const arrTime = f.arrival || f.arrivalTime || f.arrivalDateTime || f.arrTime || f.sta || '';
                const flightNum = f.flightCode || f.flightNumber || f.flight || f.carrierCode || '';

                LV(`  Flight: dep=${depTime}, arr=${arrTime}, code=${flightNum}`);

                addFlightResult({
                  type: t.type,
                  originCode: t.o,
                  originCity: oInfo.city,
                  originCountry: oInfo.country,
                  originAirport: oInfo.airport,
                  destCode: t.d,
                  destCity: dInfo.city,
                  destCountry: dInfo.country,
                  destAirport: dInfo.airport,
                  date: t.dt,
                  departure: depTime,
                  arrival: arrTime,
                  flightNumber: flightNum,
                  bookingUrl: bookingUrl(t.o, t.d, t.dt)
                });
              });
            } else {
              LV(`No flights found in parsed response for ${t.o}->${t.d}`);
              // Log what we did find for troubleshooting
              if (typeof data === 'object') {
                const allKeys = [];
                const findKeys = (obj, prefix = '') => {
                  for (const key of Object.keys(obj || {})) {
                    allKeys.push(prefix + key);
                    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
                      findKeys(obj[key], prefix + key + '.');
                    }
                  }
                };
                findKeys(data);
                LV(`All nested keys in response: ${allKeys.slice(0, 30).join(', ')}`);
              }
            }
          } else {
            LW(`Could not parse response as JSON for ${t.o}->${t.d}`);
            LV(`Raw response body: ${r.bodyText.substring(0, 500)}`);
          }
        } else {
          errorCount++;
          LW(`HTTP ${r.status} for ${t.o}->${t.d}`);
          LV(`Error response body: ${r.bodyText.substring(0, 500)}`);
        }

        // Reduced pause frequency
        if (i > 0 && i % 50 === 0 && i < tasks.length - 1) {
          showStatus('Brief pause...');
          await sleep(3000);
        }
      } catch (e) {
        errorCount++;
        LE(`Search error for ${t.o}->${t.d}: ${e.message}`);
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 5: Search Return Flights (only for found destinations)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (isRoundTrip && foundDestinationsWithFlights.size > 0 && !stopped) {
      L('');
      L('â•â•â• STEP 5: SEARCH RETURN FLIGHTS â•â•â•');
      L(`Found ${foundDestinationsWithFlights.size} destinations with outbound flights: ${[...foundDestinationsWithFlights].join(', ')}`);

      const returnTasks = [];
      [...foundDestinationsWithFlights].forEach(returnOrigin => {
        selectedOrigins.forEach(returnDest => {
          returnDates.forEach(dt => {
            const k = `${returnOrigin}|${returnDest}|${dt}|return`;
            if (!seen.has(k)) {
              seen.add(k);
              returnTasks.push({ o: returnOrigin, d: returnDest, dt, type: 'return' });
            }
          });
        });
      });

      L(`Return tasks to search: ${returnTasks.length}`);
      showStatus(`Searching ${returnTasks.length} return routes...`);

      for (let i = 0; i < returnTasks.length; i++) {
        if (stopped) { L('Search stopped by user'); break; }
        while (paused && !stopped) { showStatus('Paused...'); await sleep(500); }
        if (stopped) break;

        const t = returnTasks[i];
        setProgress(50 + (i / returnTasks.length) * 50);  // Progress 50-100% for returns
        const oInfo = getAirportInfo(t.o);
        const dInfo = getAirportInfo(t.d);
        showStatus(`â†©ï¸ ${oInfo.city} â†’ ${dInfo.city} [${i + 1}/${returnTasks.length}]`);

        try {
          await sleep(300 + Math.random() * 200);

          LV(`Searching return: ${t.o} -> ${t.d} on ${t.dt}`);

          const searchUrl = dynamicSearchUrl || 'https://multipass.wizzair.com/w6/subscriptions/json/availability';

          const r = await px(searchUrl, {
            method: 'POST',
            contentType: 'application/json',
            body: JSON.stringify({
              flightType: 'OW',
              origin: t.o,
              destination: t.d,
              departure: t.dt,
              arrival: '',
              intervalSubtype: null
            })
          });

          if (r.status === 429) {
            rateLimitCount++;
            const waitTime = rateLimitCount >= 3 ? 60000 : 15000;
            LW(`Rate limited! Waiting ${waitTime/1000}s...`);
            showStatus(`Rate limited â€” waiting ${waitTime/1000}s...`);
            await sleep(waitTime);
            if (rateLimitCount >= 3) rateLimitCount = 0;
            i--;
            continue;
          }

          rateLimitCount = 0;

          if (r.status >= 200 && r.status < 300) {
            const data = r.json();

            if (data) {
              let fl = [];
              if (data.flightsOutbound && Array.isArray(data.flightsOutbound)) fl = data.flightsOutbound;
              else if (data.flights && Array.isArray(data.flights)) fl = data.flights;
              else if (data.outbound && Array.isArray(data.outbound)) fl = data.outbound;
              else if (data.outboundFlights && Array.isArray(data.outboundFlights)) fl = data.outboundFlights;
              else if (Array.isArray(data)) fl = data;
              else if (data.result && Array.isArray(data.result)) fl = data.result;
              else if (data.data && Array.isArray(data.data)) fl = data.data;

              if (fl && fl.length > 0) {
                successCount++;
                L(`â†©ï¸ ${t.o} â†’ ${t.d} (return): ${fl.length} flights found`);

                fl.forEach(f => {
                  const depTime = f.departure || f.departureTime || f.departureDateTime || f.depTime || f.std || '';
                  const arrTime = f.arrival || f.arrivalTime || f.arrivalDateTime || f.arrTime || f.sta || '';
                  const flightNum = f.flightCode || f.flightNumber || f.flight || f.carrierCode || '';

                  addFlightResult({
                    type: 'return',
                    originCode: t.o,
                    originCity: oInfo.city,
                    originCountry: oInfo.country,
                    originAirport: oInfo.airport,
                    destCode: t.d,
                    destCity: dInfo.city,
                    destCountry: dInfo.country,
                    destAirport: dInfo.airport,
                    date: t.dt,
                    departure: depTime,
                    arrival: arrTime,
                    flightNumber: flightNum,
                    bookingUrl: bookingUrl(t.o, t.d, t.dt)
                  });
                });
              }
            }
          } else if (r.status === 400) {
            // Expected for some routes - log at verbose level only
            LV(`No return route available: ${t.o}->${t.d} (HTTP 400)`);
          } else {
            errorCount++;
            LW(`HTTP ${r.status} for return ${t.o}->${t.d}`);
          }
        } catch (e) {
          errorCount++;
          LE(`Return search error for ${t.o}->${t.d}: ${e.message}`);
        }
      }
    } else if (isRoundTrip) {
      L('No destinations with outbound flights found - skipping return search');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DONE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    L('');
    L('â•â•â• SEARCH COMPLETE â•â•â•');
    L(`Total flights found: ${searchResults.length}`);
    L(`Successful route searches: ${successCount}`);
    L(`Errors: ${errorCount}`);

    setProgress(100);
    showStatus(`Found ${searchResults.length} flights`);
    showMsg(searchResults.length > 0 ? 's' : 'w',
      searchResults.length > 0 ? `Found ${searchResults.length} flights!` : 'No flights found. Check debug log for details.');
    renderResults();

  } catch (e) {
    LE(`SEARCH FAILED: ${e.message}`);
    LE(`Stack: ${e.stack}`);
    showMsg('e', e.message);
    renderResults();
  } finally {
    searching = false;
    paused = false;
    $('bSearch').disabled = false;
    $('bPause').classList.add('hd-n');
    $('bResume').classList.add('hd-n');
    $('bStop').classList.add('hd-n');

    L('');
    L('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    L('SEARCH SESSION ENDED');
    L('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  }
}

// Export/Import
function exportResults() {
  if (!searchResults.length) { showMsg('w', 'No results to export'); return; }
  const data = {
    version: VERSION,
    exportDate: new Date().toISOString(),
    count: searchResults.length,
    flights: searchResults
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `wizz-flights-${formatDate(new Date())}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  showMsg('s', 'Results exported!');
}

function importResults(file) {
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      if (!data.flights || !Array.isArray(data.flights)) throw new Error('Invalid format');
      searchResults = data.flights;
      renderResults();
      showMsg('s', `Imported ${searchResults.length} flights!`);
    } catch (err) {
      showMsg('e', 'Import failed: ' + err.message);
    }
  };
  reader.readAsText(file);
}

function downloadLog() {
  const logText = generateLogText();
  const blob = new Blob([logText], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `aycf-debug-log-${formatDate(new Date())}.txt`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function generateLogText() {
  return `WIZZ AYCF DEBUG LOG
Generated: ${new Date().toISOString()}
Version: ${VERSION}
User Agent: ${navigator.userAgent}
Proxy: ${getProxy()}
Verbose Mode: ${verboseMode}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
LOG ENTRIES (${logs.length})
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

${logs.map(l => l.l).join('\n')}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
END OF LOG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
}

// Initialize
function init() {
  L(`Initializing AYCF Finder v${VERSION}`);
  L(`User Agent: ${navigator.userAgent}`);

  const proxy = getProxy();
  L(`Proxy configured: ${proxy ? 'Yes' : 'No'}`);

  if (proxy) {
    $('proxySetup').classList.add('hd-n');
    $('proxyUrl').value = proxy;
    $('settingsProxy').value = proxy;
  } else {
    $('loginCard').style.opacity = '.5';
  }

  loadCredentials();
  $('priorityCities').value = localStorage.getItem('wz_priority_cities') || 'TLV';
  $('verboseLog').checked = true;

  $('filterDate').value = formatDate(new Date());
  $('filterDate').min = formatDate(new Date());
  updateDateDisplay();
  $('filterDate').addEventListener('change', updateDateDisplay);

  populateCityDropdowns();

  // Multi-select change handlers
  $('filterOrigin').addEventListener('change', () => updateChips('filterOrigin', 'originChips'));
  $('filterDest').addEventListener('change', () => updateChips('filterDest', 'destChips'));

  $('workerCode').textContent = workerCode();

  LS('Initialization complete');
}

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
  // Set version display dynamically
  $('versionDisplay').textContent = 'v' + VERSION;

  $('setupHdr').onclick = () => {
    $('setupHdr').classList.toggle('op');
    $('setupBody').classList.toggle('op');
  };

  $('bCopyWorker').onclick = () => {
    $('workerCode').classList.toggle('hd-n');
    navigator.clipboard.writeText(workerCode());
  };

  $('bSaveProxy').onclick = () => {
    const u = $('proxyUrl').value.trim().replace(/\/+$/, '');
    if (!u) return;
    localStorage.setItem('wz_proxy', u);
    $('settingsProxy').value = u;
    $('proxyMsg').innerHTML = '<div class="mg mg-s">âœ… Saved</div>';
  };

  $('bTestProxy').onclick = async () => {
    const u = ($('proxyUrl').value || getProxy() || '').trim().replace(/\/+$/, '');
    if (!u) { $('proxyMsg').innerHTML = '<div class="mg mg-e">Enter URL</div>'; return; }
    $('proxyMsg').innerHTML = '<div class="mg mg-i">Testing...</div>';
    try {
      const r = await fetch(u, { headers: { 'X-Target': 'https://wizzair.com/' } });
      if (r.status >= 200 && r.status < 400) {
        $('proxyMsg').innerHTML = '<div class="mg mg-s">âœ… Proxy works!</div>';
        localStorage.setItem('wz_proxy', u);
        $('settingsProxy').value = u;
        setTimeout(() => {
          $('proxySetup').classList.add('hd-n');
          $('loginCard').style.opacity = '1';
        }, 1500);
      } else {
        $('proxyMsg').innerHTML = `<div class="mg mg-w">Status ${r.status}</div>`;
      }
    } catch (e) {
      $('proxyMsg').innerHTML = `<div class="mg mg-e">${e.message}</div>`;
    }
  };

  $('bSearch').onclick = searchFlights;
  $('bPause').onclick = () => {
    paused = true;
    $('bPause').classList.add('hd-n');
    $('bResume').classList.remove('hd-n');
    L('Search paused by user');
  };
  $('bResume').onclick = () => {
    paused = false;
    $('bResume').classList.add('hd-n');
    $('bPause').classList.remove('hd-n');
    L('Search resumed');
  };
  $('bStop').onclick = () => { stopped = true; paused = false; };

  $('bExportResults').onclick = exportResults;
  $('bImportResults').onclick = () => $('importFile').click();
  $('importFile').onchange = e => {
    if (e.target.files.length) { importResults(e.target.files[0]); e.target.value = ''; }
  };
  $('bClearResults').onclick = () => {
    searchResults = [];
    currentSort = { field: null, asc: true };
    $('resultsArea').innerHTML = '<div class="mg mg-i">No results yet.</div>';
    $('resultsCount').textContent = '0 flights';
  };

  $('bSettings').onclick = () => $('mSettings').classList.add('op');
  $('bCloseSettings').onclick = () => $('mSettings').classList.remove('op');
  $('mSettings').onclick = e => { if (e.target === $('mSettings')) $('mSettings').classList.remove('op'); };
  $('bSaveSettingsProxy').onclick = () => {
    const u = $('settingsProxy').value.trim();
    if (u) {
      localStorage.setItem('wz_proxy', u);
      $('proxyUrl').value = u;
      $('proxySetup').classList.add('hd-n');
      $('loginCard').style.opacity = '1';
    }
  };
  $('bSavePriority').onclick = () => {
    localStorage.setItem('wz_priority_cities', $('priorityCities').value.trim().toUpperCase());
    populateCityDropdowns();
    LS('Priority cities saved');
  };
  $('bClearCredentials').onclick = () => { clearCredentials(); showMsg('s', 'Credentials cleared'); };

  $('bLog').onclick = () => $('mLog').classList.add('op');
  $('bCloseLog').onclick = () => $('mLog').classList.remove('op');
  $('mLog').onclick = e => { if (e.target === $('mLog')) $('mLog').classList.remove('op'); };
  $('bClearLog').onclick = () => { logs = []; $('logArea').innerHTML = ''; $('lCnt').textContent = '(0)'; };
  $('bCopyLog').onclick = () => {
    navigator.clipboard.writeText(generateLogText()).then(() => {
      $('bCopyLog').textContent = 'âœ… Copied!';
      setTimeout(() => { $('bCopyLog').textContent = 'ğŸ“‹ Copy Full Log'; }, 2000);
    });
  };
  $('bDownloadLog').onclick = downloadLog;

  init();
});
</script>
</body>
</html>
